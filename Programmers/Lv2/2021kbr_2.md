## 문제

[순위 검색](https://school.programmers.co.kr/learn/courses/30/lessons/72412)

<br/>

## 풀이

50,000명의 지원자에 대한 정보와 100,000개의 쿼리

간단하게 생각하면, 모든 지원자에 대한 정보를 vector에 저장하고, 브루트포스로 쿼리에 맞는 사람 수를 구하면 된다.

하지만 효율성 테스트를 통과하기 위해서는 브루트포스만으로는 안된다.

```c++
#include <algorithm>
#include <cmath>
#include <string>
#include <vector>
#include <sstream>
using namespace std;

vector<string> langs = { "cpp", "java", "python" };
vector<string> jobs = { "backend", "frontend" };
vector<string> careers = { "junior", "senior" };
vector<string> foods = { "chicken", "pizza" };

vector<int> applicants[25];

int findKey(string lang, string job, string career, string food) {
    int key = 1;

    for (int i = 0; i < langs.size(); i++) {
        if (langs[i] == lang) key += pow(2, 3) * i;
    }
    for (int i = 0; i < jobs.size(); i++) {
        if (jobs[i] == job) key += pow(2, 2) * i;
    }
    for (int i = 0; i < careers.size(); i++) {
        if (careers[i] == career) key += pow(2, 1) * i;
    }
    for (int i = 0; i < foods.size(); i++) {
        if (foods[i] == food) key += pow(2, 0) * i;
    }
    return key;
}

int findApplicants(string lang, string job, string career, string food, int score) {
    int total = 0;

    for (int l = 0; l < langs.size(); l++) {
        if (langs[l] != lang && lang != "-") continue;
        for (int j = 0; j < jobs.size(); j++) {
            if (jobs[j] != job && job != "-") continue;
            for (int c = 0; c < careers.size(); c++) {
                if (careers[c] != career && career != "-") continue;
                for (int f = 0; f < foods.size(); f++) {
                    if (foods[f] != food && food != "-") continue;

                    int key = findKey(langs[l], jobs[j], careers[c], foods[f]);
                    int idx = lower_bound(
                        applicants[key].begin(), applicants[key].end(), score) - applicants[key].begin();

                    total += (applicants[key].size() - idx);
                }
            }
        }
    }
    return total;
}

vector<int> solution(vector<string> info, vector<string> query) {
    vector<int> answer;

    // 50000명, 100000개의 쿼리
    // query별로 5,000,000,000하기에는 별로
    // 이분 탐색으로 점수를 찾는다?

    // 모든 query에는 무조건 점수를 포함하므로, 점수로 사람들 거르기
    // 언어, 직군, 경력, 소울푸드 -> 3 * 2 * 2 * 2 = 24가지
    // 108가지 key.. hash?

    // 조건에 맞는 key들 갖고 와서,
    // 각 key로 코딩테스트 점수들을 기준으로 lower_bound로 index를 찾으면 되지 않을까

    for (string i : info) {
        int score;
        string lang, job, career, food;

        istringstream iss(i);
        iss >> lang >> job >> career >> food >> score;

        int key = findKey(lang, job, career, food);
        applicants[key].push_back(score);
    }

    for (int i = 1; i <= 24; i++) {
        sort(applicants[i].begin(), applicants[i].end());
    }

    for (string q : query) {
        int score;
        string lang, job, career, food, tmp;

        istringstream iss(q);
        iss >> lang >> tmp >> job >> tmp >> career >> tmp >> food >> score;

        answer.push_back(findApplicants(lang, job, career, food, score));
    }

    return answer;
}
```
