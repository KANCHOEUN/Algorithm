# 2302. 극장 좌석

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 2 초      | 128 MB      | 12175 | 5022 | 4120      | 41.840%   |

## 문제

어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다. 공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 예를 들어서, 입장권에 5번이 쓰여 있으면 5번 좌석에 앉아야 한다. 단, 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 예를 들어서, 7번 입장권을 가진 사람은 7번 좌석은 물론이고, 6번 좌석이나 8번 좌석에도 앉을 수 있다. 그러나 5번 좌석이나 9번 좌석에는 앉을 수 없다.

그런데 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다.

오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다. VIP 회원들의 좌석 번호들이 주어졌을 때, 사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 구하는 프로그램을 작성하시오.

예를 들어서, 그림과 같이 좌석이 9개이고, 4번 좌석과 7번 좌석이 VIP석인 경우에 <123456789>는 물론 가능한 배치이다. 또한 <213465789> 와 <132465798> 도 가능한 배치이다. 그러나 <312456789> 와 <123546789> 는 허용되지 않는 배치 방법이다.

<img src="https://upload.acmicpc.net/80caa675-30d4-44ec-8100-01f8eac2a3e3/-/preview/" width="60%">

<br/>

#### 입력

첫째 줄에는 좌석의 개수 N이 입력된다. N은 1 이상 40 이하이다. 둘째 줄에는 고정석의 개수 M이 입력된다. M은 0 이상 N 이하이다. 다음 M 개의 줄에는 고정석의 번호가 작은 수부터 큰 수의 순서로 한 줄에 하나씩 입력된다.

#### 출력

주어진 조건을 만족하면서 사람들이 좌석에 앉을 수 있는 방법의 가짓수를 출력한다. 방법의 가짓수는 2,000,000,000을 넘지 않는다. (2,000,000,000 < 231-1)

<br/>

## 풀이

d[i] 를 1번 좌석에서 i번 좌석까지 사람들이 앉는 서로 다른 방법의 가짓수로 정의하였다.

좌석을 배치하는 방법은 다음과 같이 분류된다.

- i번 좌석이 고정석이 아닌 경우
  - `d[i-2]` : 현재 좌석을 앞 좌석과 교체하는 경우
    - 고정석이 아니고 앞에 좌석이 VIP 석이 아닌 경우
  - `d[i-1]` : 현재 좌석을 교체하지 않는 경우
- i번 좌석이 고정석인 경우
  - `d[i-1]` : 현재 좌석을 교체하지 않는 경우

<br/>

> **주의**
>
> 모든 좌석이 고정석인 경우를 판단하지 않아서 틀렸었다.
>
> 모든 좌석이 고정석인 경우를 대비하여, d[0] = 1 이어야 한다.

<br/>

### C: bool 배열로 고정석 판단

```c
#include <stdio.h>

int d[41] = { 1, 1 };
bool vip[41] = { 0, };

int main() {
	int N, M, seat;
	scanf("%d %d", &N, &M);

	for (int i = 0; i < M; i++) {
		scanf("%d", &seat);
		vip[seat] = true;
	}

	for (int i = 2; i <= N; i++) {
		if (!vip[i] && !vip[i - 1]) { // 고정석이 아닌 경우
			d[i] += d[i - 2];
		}
		d[i] += d[i - 1];
	}

	printf("%d", d[N]);
	return 0;
}
```

<br/>

### C++: set으로 고정석 판단

```c++
#include <iostream>
#include <set>
using namespace std;

int d[41] = { 1, 1 };
set<int> vip;

int main() {
	ios_base::sync_with_stdio(false);

	int N, M, seat;
	cin >> N >> M;

	for (int i = 0; i < M; i++) {
		cin >> seat;
		vip.insert(seat);
	}

	for (int i = 2; i <= N; i++) {
		if ((vip.find(i) == vip.end()) && (vip.find(i-1) == vip.end())) { // 고정석이 아닌 경우
			d[i] += d[i - 2];
		}
		d[i] += d[i - 1];
	}

	cout << d[N];
	return 0;
}
```
