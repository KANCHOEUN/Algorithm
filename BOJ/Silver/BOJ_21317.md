# 21317. 징검다리 건너기

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 1 초      | 1024 MB     | 2968 | 905  | 620       | 28.810%   |

## 문제

심마니 영재는 산삼을 찾아다닌다.

산삼을 찾던 영재는 *N*개의 돌이 일렬로 나열되어 있는 강가를 발견했고, 마지막 돌 틈 사이에 산삼이 있다는 사실을 알게 되었다.

마지막 돌 틈 사이에 있는 산삼을 캐기 위해 영재는 돌과 돌 사이를 점프하면서 이동하며 점프의 종류는 3가지가 있다.

점프의 종류에는 현재 위치에서 다음 돌로 이동하는 작은 점프, 1개의 돌을 건너뛰어 이동하는 큰 점프, 2개의 돌을 건너뛰어 이동하는 매우 큰 점프가 있다.

각 점프를 할 때는 에너지를 소비하는데, 이 때 작은 점프와 큰 점프시 소비되는 에너지는 점프를 하는 돌의 번호마다 다르다.

매우 큰 점프는 단 한 번의 기회가 주어지는데, 이때는 점프를 하는 돌의 번호와 상관없이 *k*만큼의 에너지를 소비한다.

에너지를 최대한 아껴야 하는 영재가 산삼을 얻기 위해 필요한 에너지의 최솟값을 구하여라.

영재는 첫 번째 돌에서부터 출발한다.

#### 입력

첫 번째 줄에는 돌의 개수 *N*이 주어진다.

_N_ - 1개의 줄에 걸쳐서, 1번 돌부터 _N_ - 1번 돌 까지의 작은 점프를 하기 위해 필요한 에너지, 큰 점프를 하기 위해 필요한 에너지가 주어진다.

마지막 줄에는 *K*가 주어진다.

#### 출력

산삼을 얻기 위해 필요한 영재의 최소 에너지를 출력한다.

#### 제한

- 1 ≤ _N_ ≤ 20
- 작은 점프, 큰 점프 시 필요한 에너지와 *K*는 5,000을 넘지않는 자연수이다.

<br/>

## 풀이

- 작은 점프 (+1) 와 큰 점프 (+2) 시 소비되는 에너지
- **단 한 번**의 매우 큰 점프 (+3)

```
d[i][0/1]: 매우 큰 점프를 안했을 때와 했을 때, i번 돌까지 소비한 에너지의 최솟값
```

<br/>

초기에 넣어야 하는 값 때문에, 다음 코드와 같이 1번과 2번을 나누어서 for문을 돌렸다.

```c++
#include <stdio.h>

int min(int a, int b) { return a < b ? a : b; }

int d[22][2] = { {0, 0} };
int s[22], m[22];

int main() {
	int N, K;

	scanf("%d", &N);
	for (int i = 1; i < N; i++) {
		scanf("%d %d", &s[i], &m[i]);
	}
	scanf("%d", &K);

    // 1. 작은 점프와 큰 점프만을 사용하는 경우
	d[2][0] = s[1];
	d[3][0] = min(d[2][0] + s[2], d[1][0] + m[1]);
	for (int i = 4; i <= N; i++) {
		d[i][0] = min(d[i - 1][0] + s[i - 1], d[i - 2][0] + m[i - 2]);
	}

    // 2. 단 한 번의 매우 큰 점프를 사용하는 경우
	d[4][1] = d[1][0] + K;
	d[5][1] = min(d[4][1] + s[4], d[2][0] + K);
	for (int i = 6; i <= N; i++) {
		d[i][1] = min(min(d[i - 1][1] + s[i - 1], d[i - 2][1] + m[i - 2]), d[i - 3][0] + K);
	}

	printf("%d", N > 3 ? min(d[N][0], d[N][1]) : d[N][0]);
	return 0;
}
```
