# 1138. 한 줄로 서기

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 2 초      | 128 MB      | 10885 | 6319 | 5271      | 58.940%   |

## 문제

N명의 사람들은 매일 아침 한 줄로 선다. 이 사람들은 자리를 마음대로 서지 못하고 오민식의 지시대로 선다.

어느 날 사람들은 오민식이 사람들이 줄 서는 위치를 기록해 놓는다는 것을 알았다. 그리고 아침에 자기가 기록해 놓은 것과 사람들이 줄을 선 위치가 맞는지 확인한다.

사람들은 자기보다 큰 사람이 왼쪽에 몇 명 있었는지만을 기억한다. N명의 사람이 있고, 사람들의 키는 1부터 N까지 모두 다르다.

각 사람들이 기억하는 정보가 주어질 때, 줄을 어떻게 서야 하는지 출력하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 사람의 수 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 둘째 줄에는 키가 1인 사람부터 차례대로 자기보다 키가 큰 사람이 왼쪽에 몇 명이 있었는지 주어진다. i번째 수는 0보다 크거나 같고, N-i보다 작거나 같다. i는 0부터 시작한다.

#### 출력

첫째 줄에 줄을 선 순서대로 키를 출력한다.

<br/>

## 풀이

다음 문제 조건처럼 입력은 키를 기준으로 정렬된 상태로 주어진다.

> **키가 1인 사람부터 차례대로** 자기보다 키가 큰 사람이 왼쪽에 몇 명 있었는지 주어진다

<br/>

키가 작은 순서대로 빈 배열인 line에 위치 시켜보자

현재 line 배열은 [0, 0, 0, 0] 이다.

| 키   | 1   | 2   | 3   | 4   |
| ---- | --- | --- | --- | --- |
| left | 2   | 1   | 1   | 0   |

- 키가 1인 사람은 왼쪽에 자신보다 큰 사람이 2명 위치해 있다.

  line 배열에서 '0' 은 앞으로 배치될 자신보다 키가 큰 사람이다.

  따라서 line 배열에서 2개의 0을 지난, 3번째에 1이 배치된다.

  즉 line 배열은 [0, 0, 1, 0] 가 된다

- 키가 2인 사람은 왼쪽에 자신보다 큰 사람이 1명 위치해 있다.

  따라서 line 배열에서 1개의 0을 지난, 2번째에 2가 배치된다.

  즉 line 배열은 [0, 2, 1, 0] 가 된다.

- 키가 3인 사람은 왼쪽에 자신보다 큰 사람이 1명 위치해 있다.

  line 배열에서 '0'이 아닌 숫자들은 자신보다 키가 작은 사람들이 위치한 곳이다.

  따라서 line 배열에서 1개의 0을 지나고, 배치된 위치를 지나면 가장 마지막인 4번째에 3이 배치된다.

  즉 line 배열은 [0, 2, 1, 3] 이 된다.

이를 코드로 나타내면 다음과 같다.

<br/>

```c++
#include <iostream>
using namespace std;

int line[11] = { 0, };
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);

	int N, left;
	cin >> N;
	for (int i = 1; i <= N; i++) {
		cin >> left;

		int idx = 0, cnt = 0;
		while (1) { // 들어갈 위치 찾기
			if (line[idx] != 0) {
				idx++;
				continue;
			}
			if (cnt == left) {
				line[idx] = i;
				break;
			}
			idx++; cnt++;
		}
	}

	for (int i = 0; i < N; i++) {
		cout << line[i] << " ";
	}
	return 0;
}
```
