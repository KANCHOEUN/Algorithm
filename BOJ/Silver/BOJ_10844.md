# 10844. 쉬운 계단 수

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 초      | 256 MB      | 52960 | 15864 | 11461     | 28.213%   |

## 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.

세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

#### 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

#### 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

<br/>

## 풀이

$d[i][j]$ 는 길이가 i 이고 마지막 수가 j 인 계단 수의 개수를 나타냄

마지막 수가 무엇이냐에 따라서 다음 값이 결정됨

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
|     | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |     |

0 과 9 를 제외하고 $d[i][j] = d[i-1][j-1]+d[i-1][j+1]$ 를 만족함

#### Bottom-Up

```c++
#include <stdio.h>

int d[101][10] = {0,};

int main() {
    int N;
    int sum = 0;

    scanf("%d", &N);

    for (int i = 1; i <= 9; i++) {
        d[1][i] = 1;
    }

    for (int i = 2; i <= N; i++) {
        for(int j = 0; j <= 9; j++) {
            if(j == 0) {
                d[i][j] += d[i-1][j+1];
            } else if(j == 9) {
                d[i][j] += d[i-1][j-1];
            } else {
                d[i][j] = d[i - 1][j - 1] + d[i - 1][j + 1];
            }
            d[i][j] %= 1000000000;
        }
    }

    for(int i = 0; i <= 9; i++) {
        sum += d[N][i];
        sum %= 1000000000;
    }

    printf("%d", sum);

    return 0;
}
```
