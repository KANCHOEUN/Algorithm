# 15990. 1, 2, 3 더하기 5

| 시간 제한             | 메모리 제한 | 제출  | 정답 | 맞힌 사람 | 정답 비율 |
| :-------------------- | :---------- | :---- | :--- | :-------- | :-------- |
| 1 초 (추가 시간 없음) | 512 MB      | 22006 | 7467 | 5199      | 30.965%   |

## 문제

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

- 1+2+1
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.

#### 출력

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.

<br/>

## 풀이

같은 수를 두 번 이상 연속해서 사용하면 안된다는 조건을 통해

이전에 사용한 마지막 수가 1, 2, 3 중 무엇인지 알아야 된다 라는 사실을 알 수 있다.

이를 통해 점화식을 다음과 같이 정의했을 때,

```
d[N][i]: 정수 N을 만드는 방법 중, 마지막에 i가 위치하는 경우
```

정수 N을 1, 2, 3의 합으로 나타내는 방법은 다음과 같이 나타낼 수 있다.

```
d[N][1] = d[N - 1][2] + d[N - 1][3]
d[N][2] = d[N - 2][1] + d[N - 2][3]
d[N][3] = d[N - 3][1] + d[N - 3][2]
```

<br/>

```c++
#include <stdio.h>
#define MOD 1000000009

long long d[100001][4] = { {0, 0, 0, 0},
                     {0, 1, 0, 0},
                     {0, 0, 1, 0},
                     {0, 1, 1, 1} };

int main() {
    int T, N;
    scanf("%d", &T);

    for (int i = 4; i < 100001; i++) {
        d[i][1] = (d[i - 1][2] + d[i - 1][3]) % MOD;
        d[i][2] = (d[i - 2][1] + d[i - 2][3]) % MOD;
        d[i][3] = (d[i - 3][1] + d[i - 3][2]) % MOD;
    }

    for (int i = 0; i < T; i++) {
        scanf("%d", &N);
        printf("%lld\n", (d[N][1] + d[N][2] + d[N][3]) % MOD);
    }
    return 0;
}
```
