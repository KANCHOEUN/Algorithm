# 11048. 이동하기

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 1 초      | 256 MB      | 16361 | 9494 | 6591      | 58.291%   |

#### 문제

준규는 N×M 크기의 미로에 갇혀있다. 미로는 1×1크기의 방으로 나누어져 있고, 각 방에는 사탕이 놓여져 있다. 미로의 가장 왼쪽 윗 방은 (1, 1)이고, 가장 오른쪽 아랫 방은 (N, M)이다.

준규는 현재 (1, 1)에 있고, (N, M)으로 이동하려고 한다. 준규가 (r, c)에 있으면, (r+1, c), (r, c+1), (r+1, c+1)로 이동할 수 있고, 각 방을 방문할 때마다 방에 놓여져있는 사탕을 모두 가져갈 수 있다. 또, 미로 밖으로 나갈 수는 없다.

준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최댓값을 구하시오.

#### 입력

첫째 줄에 미로의 크기 N, M이 주어진다. (1 ≤ N, M ≤ 1,000)

둘째 줄부터 N개 줄에는 총 M개의 숫자가 주어지며, r번째 줄의 c번째 수는 (r, c)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다.

#### 출력

첫째 줄에 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수를 출력한다.

<br/>

## 풀이

DP 문제

#### d\[i][j] : (1, 1) 에서 (i, j) 로 이동할 때까지 가져올 수 있는 사탕 개수의 최댓값

(i+1, j) 로 이동한 경우 : d\[i-1][j]

(i, j+1) 로 이동한 경우 : d\[i][j-1]

(i+1, j+1) 로 이동한 경우 : d\[i-1][j-1]

위의 세 가지 경우 중 최댓값을 선택

<br/>

#### d\[i] : 1 열에서 i 열로 이동할 때까지 가져올 수 있는 사탕 개수의 최댓값

1. 사탕의 개수는 음수가 아니므로

   한 번 대각선으로 이동하는 것보다

   아래로 이동하고 오른쪽으로 이동하는 것이 더 많은 사탕을 얻을 수 있음

   **a\[i+1][j] + a\[i+1][j+1] >= a\[i+1][j+1]** ( a : 사탕의 개수를 저장한 배열 )

2. 왼쪽에서 오른쪽으로 그리고 위에서 아래로, 즉 **양의 방향으로 이동**하고

   ( y 축을 기준으로 아래 방향이 양의 방향, x 축을 기준으로 오른쪽 방향이 양의 방향인 좌표계를 기준으로 )

   비교 해야 하는 값이 d\[i][j] 를 기준으로 **위의 값**과 **왼쪽의 값** 두가지 이므로

   1차원 배열로 점화식을 세울 수 있음

1 과 2 에 의해 `d[j] = max(d[j], d[j-1]) + (현재 위치의 사탕 개수)` 로 나타낼 수 있다.

> d[j] 는 현재 위치를 기준으로 위의 값을 나타내고,
>
> d[j-1] 는 현재 위치를 기준으로 왼쪽의 값을 나타냄

<br/>

#### 1. 2차원 배열

```c++
#include <stdio.h>
int d[1001][1001] = {0, };

int max(int a, int b) { return a > b ? a : b; }

int main() {
    int n, m, tmp;
    scanf("%d %d", &n, &m);

    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            scanf("%d", &tmp);
            d[i][j] = max(max(d[i-1][j], d[i][j-1]), d[i-1][j-1]) + tmp;
        }
    }

    printf("%d", d[n][m]);

    return 0;
}
```

<br/>

#### 2. 1차원 배열

```c
#include <stdio.h>
#define max(a, b) (a>b?a:b)
int main() {
    int n, m, tmp, d[1001] = {0, };
    scanf("%d %d", &n, &m);

    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            scanf("%d", &tmp);
            d[j] = max(d[j], d[j-1]) + tmp;
        }
    }

    printf("%d", d[m]);
    return 0;
}
```
