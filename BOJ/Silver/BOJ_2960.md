# 2960. 에라토스테네스의 체

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 1 초      | 128 MB      | 14020 | 7100 | 6004      | 51.567%   |

#### 문제

에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾는 유명한 알고리즘이다.

이 알고리즘은 다음과 같다.

1. 2부터 N까지 모든 정수를 적는다.
2. 아직 지우지 않은 수 중 가장 작은 수를 찾는다. 이것을 P라고 하고, 이 수는 소수이다.
3. P를 지우고, 아직 지우지 않은 P의 배수를 크기 순서대로 지운다.
4. 아직 모든 수를 지우지 않았다면, 다시 2번 단계로 간다.

N, K가 주어졌을 때, K번째 지우는 수를 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 N과 K가 주어진다. (1 ≤ K < N, max(2, K) < N ≤ 1000)

#### 출력

첫째 줄에 K번째 지워진 수를 출력한다.

#### 예제 입력 1

```
10 7
```

#### 예제 출력 1

```
9
```

#### 힌트

2, 4, 6, 8, 10, 3, 9, 5, 7 순서대로 지워진다. 7번째 지워진 수는 9이다.

<br/>

## 풀이

#### 주의

기존 에라토스테네스의 체 알고리즘 구현 문제에서

최적화를 위해 2부터 sqrt(N) 까지 구했지만,

해당 문제에서는 N 까지 모든 정수를 지워나가는 과정 중에서 K 번째로 지우는 숫자를 찾으므로

sqrt(N) 이 아닌 N 까지로 범위를 바꾸어야 함

<br/>

```c++
#include <stdio.h>
#include <string.h>

int main() {
    int N, K, p[1001], res = 2;
    memset(p, 1, sizeof(p));
    p[0] = p[1] = 0;
    scanf("%d %d", &N, &K);

    for(int i = 2; K > 0 && i <= N; i++) {
        if(p[i]) {
            for(int j = i; K > 0 && j <= N; j += i) {
                if(p[j]) {
                    p[j] = 0;
                    K--;
                }
                if(K == 0) res = j;
            }
        }
    }

    printf("%d", res);
    return 0;
}
```
