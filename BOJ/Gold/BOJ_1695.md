# 1695. 팰린드롬

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 128 MB      | 5553 | 1933 | 1399      | 35.955%   |

## 문제

앞에서 뒤로 보나, 뒤에서 앞으로 보나 같은 수열을 팰린드롬 이라고 한다. 예를 들어 {1}, {1, 2, 1}, {1, 2, 2, 1}과 같은 수열은 팰린드롬 이지만, {1, 2, 3}, {1, 2, 3, 2} 등은 팰린드롬이 아니다.

한 수열이 주어졌을 때, 이 수열에 최소 개수의 수를 끼워 넣어 팰린드롬을 만들려고 한다. 최소 몇 개의 수를 끼워 넣으면 되는지를 알아내는 프로그램을 작성하시오.

#### 입력

첫째 줄에 수열의 길이 N(1≤N≤5,000)이 주어진다. 다음 줄에는 N개의 수열을 이루는 수들이 주어진다. 각 수들은 int 범위이다.

#### 출력

첫째 줄에 끼워 넣을 수들의 최소 개수를 출력한다.

<br/>

## 풀이

점화식을 만들기가 너무 어려워서 다른 사람들의 아이디어를 참고한 문제

<br/>

##### d\[i][j]: i부터 j 인덱스까지의 부분 배열에서 팰린드롬을 만들기 위해 끼워 넣어야 할 최소 개수

위와 같은 점화식을 세운다면, 정답은 d\[0][N-1] 이 된다.

<br/>

두 포인터를 두어 팰린드롬인지 여부를 먼저 파악한 후,

팰린드롬으로 만들기 위해 끼워 넣는 방법은 두 가지가 있다.

1. a[i] == a[j] 인 경우, 두 포인터 i, j 모두 그 다음 위치인 i+1, j-1 를 가리킨다.
2. a[i] != a[j] 인 경우
   - 왼쪽 포인터에 끼워 넣는 경우: i, j -1
   - 오른쪽 포인터에 끼워 넣는 경우: i+1, j

<br/>

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

int a[5005], d[5005][5005];

int f(int i, int j) {
	if (i >= j) return 0;
	if (d[i][j] != -1) return d[i][j];

	d[i][j] = 0;
	if (a[i] == a[j]) return d[i][j] += f(i + 1, j - 1);
	return d[i][j] += min(f(i, j - 1), f(i + 1, j)) + 1;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int N;
	cin >> N;
	for (int i = 0; i < N; i++) {
		cin >> a[i];
	}
	memset(d, -1, sizeof(d));
	cout << f(0, N - 1);

	return 0;
}
```
