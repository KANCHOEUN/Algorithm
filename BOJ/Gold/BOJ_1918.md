# 1918. 후위 표기식

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 2 초      | 128 MB      | 34958 | 12388 | 9299      | 35.219%   |

## 문제

수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 `a+b`는 전위 표기법으로는 `+ab`이고, 후위 표기법으로는 `ab+`가 된다.

이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 `a+b*c`를 후위 표기식으로 바꾸면 `abc*+`가 된다.

중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.

예를 들어 `a+b*c`는 `(a+(b*c))`의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 `*`를 괄호 밖으로 꺼내게 되면 `(a+bc*)`가 된다. 마지막으로 또 `+`를 괄호의 오른쪽으로 고치면 `abc*+`가 되게 된다.

다른 예를 들어 그림으로 표현하면 `A+B*C-D/E`를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.

![img](https://upload.acmicpc.net/5aad2feb-d9fc-430a-954d-73a06ba0215f/-/preview/)

결과: `ABC*+DE/-`

이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오

#### 입력

첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 알파벳 대문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 `-A+B`와 같이 `-`가 가장 앞에 오거나 `AB`와 같이 `*`가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 `+`, `-`, `*`, `/`, `(`, `)`로만 이루어져 있으며, 길이는 100을 넘지 않는다.

#### 출력

첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오

<br/>

## 풀이

우선순위를 고려해서, 후위 표기식으로 변환하는 문제

문제에서는 중위 표기식을 후위 표기식으로 변환하는 방법을 다음과 같이 알려주었다.

1. 우선순위에 따라 괄호로 묶어주기

   > 우선순위는 `(` , `)` > `*` , `/` > `+` , `-` 와 같은 순서를 갖는다.

2. 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주기

이를 프로그램으로 나타내기 위해서는 어떻게 해야할까?

<br/>

다음과 같은 표기식이 있다고 하자.

```
A*(B+C)-D
```

A 다음으로 나오는 `*` 연산자보다 괄호 안에 있는 `+` 연산자가 더 높은 우선순위를 갖는다.

하지만 한 눈에 보고 판단할 수 있는 우리와는 달리, 컴퓨터 프로그램은 좌측에서 우측으로 순차적으로 탐색하므로

현재 탐색하고 있는 연산자의 우선순위를 판단하기 힘들다.

예를 들어, A 다음에 나오는 `*` 연산자 탐색 시, 뒤에 `(` 괄호가 나오는지 알 수 없다.

우리는 이를 스택에 연산자를 저장하여, 이러한 우선순위 판단을 뒤로 미룸으로써 해결할 수 있다.

<br/>

그렇다면 스택에 있는 연산자는 언제 제거할까?

스택에 추가할 때와 마찬가지로 새로운 연산자가 나왔을 때,

스택의 top부터 스택에 있는 연산자들과 비교하면서,

스택이 빌 때까지 혹은 자신의 우선순위보다 낮은 연산자들이 나올 때까지,

자신의 우선순위보다 같거나 높은 우선순위를 가진 연산자들을 pop하면 된다.

이후, 현재 자신의 연산자를 스택에 push한다.

<br/>

이를 코드로 나타내면 다음과 같다.

```c++
#include <iostream>
#include <string>
#include <stack>
using namespace std;

// 연산자 우선순위 부여해주는 함수
int priority(char c) {
	int p = 0;
	if (c == '+' || c == '-') {
		p = 1;
	} else if (c == '*' || c == '/') {
		p = 2;
	}
	return p;
}

int main() {
	ios_base::sync_with_stdio(false);

	stack<char> s;
	string str;
	cin >> str;

	for (int i = 0; i < str.size(); i++) {
		char c = str[i];

		if ('A' <= c && c <= 'Z') {
			cout << c;
		} else if (c == '(') {
			s.push(c);
		} else if (c == ')') { // 괄호가 닫히면,
			while (s.top() != '(') { // 괄호가 열린 부분까지
				cout << s.top();
				s.pop();
			}
			s.pop();
		} else { // +, -, *, / 연산자가 나온 경우
            // 자신의 우선순위와 같거나 높은 연산자들 pop하기
			while (!s.empty() && (priority(s.top()) >= priority(c))) {
				cout << s.top();
				s.pop();
			}
			s.push(c);
		}
	}
    // 남아 있는 연산자들 pop하기
	while (!s.empty()) {
		cout << s.top();
		s.pop();
	}

	return 0;
}
```

<br/>
