# 1655. 가운데를 말해요

| 시간 제한                                                   | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| :---------------------------------------------------------- | :---------- | :---- | :---- | :-------- | :-------- |
| 0.1 초 ([하단 참고](https://www.acmicpc.net/problem/1655#)) | 128 MB      | 46756 | 13599 | 10240     | 30.543%   |

## 문제

백준이는 동생에게 "가운데를 말해요" 게임을 가르쳐주고 있다. 백준이가 정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 **짝수개라면 중간에 있는 두 수 중에서 작은 수**를 말해야 한다.

예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.

#### 출력

한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.

<br/>

## 풀이

정렬된 배열 [0, N]이 있다고 하자. 이 때, 중간값은 다음과 같이 표현할 수 있다.

> 정렬된 배열 [0, N] 을 반으로 쪼개면, [0, N/2 - 1] , [N/2, N] 두 개의 배열로 나타낼 수 있다.
>
> 여기서 중간값은 좌측 배열의 최댓값, 우측 배열의 최솟값 중 하나이다.
>
> (단, 해당 문제에서 짝수일 때, 중간 두 수 중 작은 수를 중간값으로 정의했기 때문에, 가운데 값은 N/2 - 1이다.)

<br/>

그렇다면, 삽입할 때마다 정렬된 배열을 어떻게 만들 수 있을까? 어떻게 삽입을 해야할까?

1. 중간에 있는 값을 구하기 위해 좌측 배열과 우측 배열의 크기 차이가 1 이하여야 한다.

   따라서 **좌측**에 한 번, **우측**에 한 번, **번갈아가며 삽입**을 함으로써 절반 크기의 배열을 만들어야 한다.

2. 삽입할 때마다, 좌측 배열과 우측 배열은 정렬된 채로 유지되어야 한다.

3. 두 배열을 합쳤을 때 정렬 상태를 유지하기 위해, **좌측 배열의 최댓값**이 **우측 배열의 최솟값보다 작아야 한다**.

2, 3 조건에 의해 우리는 힙 자료구조를 사용하는 C++ STL의 priority_queue를 활용하려 한다.

좌측 배열은 **최대 힙**으로, 우측 배열을 **최소 힙**으로 만들면, 삽입할 때마다 최댓값, 최솟값을 빠르게 구할 수 있다.

<br/>

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

priority_queue<int> lpq;
priority_queue<int, vector<int>, greater<int> > rpq;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int N, num;
	cin >> N;

	for (int i = 0; i < N; i++) {
		cin >> num;

		/* 삽입 */
		if (lpq.size() == rpq.size()) {
			lpq.push(num);
		} else {
			rpq.push(num);
		}

		/* 정렬 */
		if (!lpq.empty() && !rpq.empty() && lpq.top() > rpq.top()) {
			int tmp1 = lpq.top();
			int tmp2 = rpq.top();

			lpq.pop();
			rpq.pop();
			lpq.push(tmp2);
			rpq.push(tmp1);
		}

		/* 중간값 출력 */
		cout << lpq.top() << "\n";
	}

	return 0;
}
```
