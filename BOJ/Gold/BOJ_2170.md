# 2170. 선 긋기

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 1 초      | 192 MB      | 13825 | 4936 | 3651      | 36.166%   |

## 문제

매우 큰 도화지에 자를 대고 선을 그으려고 한다. 선을 그을 때에는 자의 한 점에서 다른 한 점까지 긋게 된다. 선을 그을 때에는 이미 선이 있는 위치에 겹쳐서 그릴 수도 있는데, 여러 번 그은 곳과 한 번 그은 곳의 차이를 구별할 수 없다고 하자.

이와 같은 식으로 선을 그었을 때, 그려진 선(들)의 총 길이를 구하는 프로그램을 작성하시오. 선이 여러 번 그려진 곳은 한 번씩만 계산한다.

#### 입력

첫째 줄에 선을 그은 횟수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 다음 N개의 줄에는 선을 그을 때 선택한 두 점의 위치 x, y(-1,000,000,000 ≤ x < y ≤ 1,000,000,000)가 주어진다.

#### 출력

첫째 줄에 그은 선의 총 길이를 출력한다.

<br/>

## 풀이

#### 겹치는 부분은 한 번씩만 계산하려면 어떻게 해야할까?

가장 간단한 방법으로는 bool 배열을 두어서, 입력 받은 두 점들의 사이를 모두 색칠하는 것이다.

하지만 주어진 조건에 의해 두 점 위치의 범위가 -10억 ~ 10억 사이로 약 20억으로,

원소의 개수가 20억인 배열을 필요로 하여, 메모리 초과가 발생한다.

<br/>

이 때, 스윕 라인 알고리즘을 사용할 수 있다.

> ##### 스윕 라인 (sweep line) 알고리즘
>
> 스윕 라인의 기본 아이디어는 평면 위에 수직선 하나가 왼쪽에서부터 오른쪽으로 쭉 스캔하는 것
>
> 여기서 중요한 점은 정렬된 순서대로 스캔한다는 점이다.

<br/>

1. 선분의 start 지점을 기준으로 정렬

2. 좌측의 start 지점부터 차례대로 탐색

   겹치는 선분을 한 번만 계산하기 위해서 겹치는지 여부를 판단해야 한다.

   겹치는 선분을 하나의 선분으로 만들기 위해,

   해당 선분의 처음 지점과 마지막 지점을 각각 s 변수와 e 변수로 두었다.

   - 현재 선분의 start 지점이, 이전 선분의 end 지점보다 클 경우 => 겹치지 않음
     - 결과값에 이전까지의 선분 길이를 더해준다.
     - s 변수와 e 변수를 각각 현재 선분의 start 지점과 end 지점으로 초기화
   - 현재 선분의 start 지점이, 이전 선분의 end 지점보다 작을 경우 => 겹침
     - s 변수는 그대로 두고,
     - 현재 선분 end 지점이 이전 선분 end 지점보다 클 경우, e 변수를 업데이트

<br/>

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

vector<pair<int, int> > v;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	int N, x, y, len = 0;

	cin >> N;
	for (int i = 0; i < N; i++) {
		cin >> x >> y;
		v.push_back({ x, y });
	}
	sort(v.begin(), v.end());

	int s = v[0].first, e = v[0].second;
	for (int i = 1; i < N; i++) {
		int cs = v[i].first, ce = v[i].second;
		if (e < cs) {
			len += (e - s);
			s = cs; e = ce;
		} else {
			if (e < ce) {
				e = ce;
			}
		}
	}
	len += (e - s);

	cout << len;
	return 0;
}
```
