# 1749. 점수따먹기

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 128 MB      | 1696 | 570  | 446       | 32.626%   |

## 문제

동주는 항상 혼자 노느라 심심하다. 하지만 혼자 놀기의 고수가 된 동주는 매일매일 게임을 개발하여 혼자놀기의 진수를 우리에게 보여준다. 어느 날 동주는 새로운 게임을 개발하였다. 바로 점수 따먹기라는 게임인데 그다지 재밌어 보이지는 않는다.

동주가 개발한 게임은 이렇다. 일단 N\*M 행렬을 그린 다음, 각 칸에 -10,000 이상 10,000 이하의 정수를 하나씩 쓴다. 그런 다음 그 행렬의 부분행렬을 그려 그 안에 적힌 정수의 합을 구하는 게임이다.

동주가 혼자 재밌게 놀던 중 지나가는 당신을 보고 당신을 붙잡고 게임을 하자고 한다. 귀찮은 당신은 정수의 합이 최대가 되는 부분행렬을 구하여 빨리 동주에게서 벗어나고 싶다.

#### 입력

첫째 줄에 N (1 < N < 200), M (1 < M < 200)이 주어진다. 그 다음 N개의 줄에 M개씩 행렬의 원소가 주어진다.

#### 출력

첫째 줄에 최대의 합을 출력하라.

<br/>

## 풀이

2차원 배열 누적 합을 구한 후, 각각 부분 행렬을 모두 계산해보고 최댓값을 찾는 방법

<br/>

#### 1. 4중 for문

```c++
#include <stdio.h>
#define MAX 4000000000 // 200 * 200 * 100000

int m[202][202];
long long s[202][202];

int main() {
	int N, M;
	long long res = -MAX; // 최솟값
	scanf("%d %d", &N, &M);

	for (int i = 1; i <= N; i++) {
		for (int j = 1; j <= M; j++) {
			scanf("%d", &m[i][j]);
			s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + m[i][j];
		}
	}

	for (int i = 1; i <= N; i++) { // 큰 행
		for (int j = 1; j <= M; j++) { // 큰 열
			for (int a = 1; a <= i; a++) { // 작은 행
				for (int b = 1; b <= j; b++) { // 작은 열
					long long tmp = s[i][j] - s[a - 1][j] - s[i][b - 1] + s[a - 1][b - 1];
					if (res < tmp) res = tmp;
				}
			}
		}
	}
	printf("%lld", res);

	return 0;
}
```
