# 2225. 합분해

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 2 초      | 128 MB      | 36199 | 16011 | 11743     | 42.728%   |

## 문제

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

#### 입력

첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

#### 출력

첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

<br/>

## 풀이

점화식을 다음과 같이 정의하였다.

```
d[N][K]: 0부터 N까지의 정수 K개를 더해서 합이 N이 되는 경우의 수
```

<br/>

작은 수부터 생각해보자.

- K = 0 일 때는, 만들 수 있는 수가 없으므로 d\[N][0] 은 언제나 0이다.

- K = 1 일 때는, 언제나 만들 수 있는 수가 자기 자신, 1개로 d\[N][1] 은 1이다.

<br/>

K = 2 이고 N = 2 일 때, 정수 2개를 더해서 합이 2가 되는 경우의 수는 어떻게 될까?

세 가지 경우의 수가 있고, 다음과 같이 표현할 수 있다.

- 0 + 2 = (정수 1개를 더해서 0이 되는 경우) + 2
- 1 + 1 = (정수 1개를 더해서 1이 되는 경우) + 1
- 2 + 0 = (정수 1개를 더해서 2가 되는 경우) + 0

이를 다시 표현하면, d\[2][2] = d\[2][1] + d\[1][1] + d\[0][1] 로 나타낼 수 있다.

<br/>

정리하면 다음과 같은 점화식을 도출할 수 있다.

```
d[N][K] = d[N][K-1] + d[N-1][K-1] + ... + d[0][K-1]
```

<br/>

```c
#include <stdio.h>
#define MOD 1000000000

long long d[201][201] = { 0, }; // d[N][K]

int main() {
	int N, K;

	scanf("%d %d", &N, &K);
	for (int i = 0; i <= N; i++) {
		d[i][1] = 1;
	}

	for (int k = 2; k <= K; k++) {
		for (int n = 0; n <= N; n++) {
			for (int i = 0; i <= n; i++) {
				d[n][k] += d[i][k-1];
			}
			d[n][k] %= MOD;
		}
	}

	printf("%lld", d[N][K]);
	return 0;
}
```
