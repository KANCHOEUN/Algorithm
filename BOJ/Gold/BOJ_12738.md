# 12738. 가장 긴 증가하는 부분 수열 3

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 3 초      | 512 MB      | 10521 | 5952 | 4848      | 62.330%   |

## 문제

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

#### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)

#### 출력

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

<br/>

## 풀이

DP로 풀 수 있는 가장 긴 증가하는 부분 수열 11053번 문제와는 다르게, O(N^2) 풀이로 풀 수 없는 문제이다.

해당 문제는 범위 때문에 이분 탐색을 활용하는 lower bound를 이용하여 O(NlogN) 만에 풀어야 한다.

입력 받는 배열을 A라 하고, A 배열 외에 다음과 같은 L 배열을 둔다.

```
L[i] : 길이가 i인 증가하는 부분 수열을 만들 수 있는, 마지막 원소 중 가장 작은 값
```

<br/>

A 배열을 탐색하면서

- L 배열이 비어있거나, 현재 A[i] 값이 L 배열의 마지막 값보다 큰 경우

  => L 배열에 A[i] 값을 추가해준다.

- 그 외의 경우

  => lower bound를 활용하여 L 배열에서 A[i]보다 같거나 큰 위치를 찾고, 이 값을 A[i]로 변경해준다.

<br/>

#### 해당 알고리즘이 왜 타당할까?

L[i] 배열의 의미를 파악하면 알 수 있다.

부분 증가 수열을 Increasing Subsequence를 줄여, IS라고 하면,

L[i]는 i개의 원소를 가진 모든 IS들 중, 가장 작은 값을 가지는 마지막(i번째) 원소이다.

즉 L 배열은 실제 최장 증가 부분 수열과는 다를 수 있지만,

L 배열의 길이는 우리가 구하고자 하는 가장 긴 IS 수열의 길이와 같으므로 대체해서 구할 수 있다.

<br/>

#### 예제

다음과 같은 A 배열이 있다고 하자.

| 10  | 20  | 5   | 30  | 15  | 25  |
| --- | --- | --- | --- | --- | --- |

<br/>

A 배열을 토대로 L 배열을 만들면 다음과 같은 순서로 채워진다.

**[ idx = 0일 때, L 배열 ]**

| 10  |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- |

L 배열의 크기가 0이었으므로, 현재 값을 push해준다.

<br/>

**[ idx = 1일 때, L 배열 ]**

| 10  | 20  |     |     |     |     |
| --- | --- | --- | --- | --- | --- |

L 배열의 마지막 원소는 현재까지 길이가 1인 최장 IS들 중 마지막 원소가 가장 작은 값을 만족하기 때문에, 보다 큰 값인 20이 나타났으므로 push될 수 있다.

<br/>

**[ idx = 2일 때, L 배열 ]**

| 5   | 20  |     |     |     |     |
| --- | --- | --- | --- | --- | --- |

idx = 2일 때, 가장 마지막 값인 20보다 5가 작으므로, push 될 수 없다.

lower bound 값 (5보다 같거나 큰 값 중 처음 위치) 을 찾아 바꾸면, L 배열의 0번째 위치가 5로 변경된다.

이는 현재 idx = 2까지 탐색했을 때, 길이가 1인 IS들 중 마지막 원소가 가장 작은 값이 5라는 뜻이다.

> idx = 2일 때까지 만들 수 있는 길이가 1인 A 배열의 IS는 [10], [5] 이고,
>
> 이 중 마지막 원소가 가장 작은 값은 5이다.

<br/>

**[ idx = 3일 때, L 배열 ]**

| 5   | 20  | 30  |     |     |     |
| --- | --- | --- | --- | --- | --- |

idx = 3일 때, 가장 마지막 값인 20보다 30이 크므로, L 배열에 push 해준다.

길이가 3인 IS들 중 마지막 원소가 가장 작은 값이 30이라는 뜻이다.

우리는 [5, 20, 30] 이라는 부분 배열을 만들 수 없다는 것을 주의해야 한다.

<br/>

**[ idx = 4일 때, L 배열 ]**

| 5   | 15  | 30  |     |     |     |
| --- | --- | --- | --- | --- | --- |

**[ idx = 5일 때, L 배열 ]**

| 5   | 15  | 25  |     |     |     |
| --- | --- | --- | --- | --- | --- |

탐색한 결과, idx = 4일 때와 idx = 5일 때, 값은 변하지만 길이는 변하지 않는다.

마지막으로 구한 L 배열이 우연히 우리가 구하는 LIS들 중 하나이지만,

idx = 3일 때와 마찬가지로 항상 우리가 구하고자 하는 LIS일 수 없다.

해당 배열은 그저 해당 길이로 만들 수 있는 IS들의 마지막 원소들 중 가장 작은 값들을 나타낼 뿐이다.

<br/>

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

vector<int> L;
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	int N, cur;
	cin >> N;
	while (N--) {
		cin >> cur;

		if (L.size() == 0 || cur > L.back()) {
			L.push_back(cur);
		} else {
			auto it = lower_bound(L.begin(), L.end(), cur);
			*it = cur;
		}
	}

	cout << L.size();
	return 0;
}
```

<br/>
