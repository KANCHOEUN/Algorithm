# 14719. 빗물

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 1 초      | 256 MB      | 12528 | 6984 | 5518      | 56.094%   |

## 문제

2차원 세계에 블록이 쌓여있다. 비가 오면 블록 사이에 빗물이 고인다.

![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/1.png)![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/2.png)

비는 충분히 많이 온다. 고이는 빗물의 총량은 얼마일까?

#### 입력

첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)

두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.

따라서 블록 내부의 빈 공간이 생길 수 없다. 또 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.

#### 출력

2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력하여라.

빗물이 전혀 고이지 않을 경우 0을 출력하여라.

<br/>

## 풀이

사고를 전환해서, x축 방향이 아닌 y축 방향으로 탐색하면 쉬워진다.

문제의 그림을 살펴보자.

1을 블록이 있는 곳이라 하고, 0을 블록이 없는 곳이라 하자.

<br/>

##### 높이가 2일 때

| 1   | 0   | 1   | 1   | 1   | 0   | 0   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- |

x축 방향으로 탐색하면서, 1이 나온 이후부터 1이 나올 때까지 0의 개수를 센다.

만약 한 번 더 1이 나오면, res 값에 더해주고, 0의 개수를 초기화한다.

- 1 -> 0 -> 1 해서 res는 1이 되고
- 1 -> 1 -> 0 -> 0 -> 1 해서 res는 1+2로 3이 된다

##### 높이가 4일 때

| 0   | 0   | 0   | 0   | 1   | 0   | 0   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |

처음 1이 나온 이후로, 0의 개수를 세면 3이 되지만, 이후 1이 나오지 않았으므로, res에 0의 개수를 더할 일이 없다.

<br/>

```c++
#include <iostream>
using namespace std;

int block[505][505];
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int W, H, h, cnt = 0, res = 0;
	cin >> H >> W;

	for (int i = 0; i < W; i++) {
		cin >> h;
		for (int j = 0; j < h; j++) {
			block[i][j] = 1;
		}
	}

	for (int j = 0; j < H; j++) {
		int flag = 0, cnt = 0;
		for (int i = 0; i < W; i++) {
			if (block[i][j] == 0) {
				if (flag > 0) cnt++;
			} else {
				flag = 1;
				res += cnt;
				cnt = 0;
			}
		}
	}
	cout << res;
	return 0;
}
```
