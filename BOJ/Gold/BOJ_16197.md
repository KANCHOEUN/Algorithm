# 16197. 두 동전

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 512 MB      | 9291 | 4097 | 2776      | 42.375%   |

## 문제

N×M 크기의 보드와 4개의 버튼으로 이루어진 게임이 있다. 보드는 1×1크기의 정사각형 칸으로 나누어져 있고, 각각의 칸은 비어있거나, 벽이다. 두 개의 빈 칸에는 동전이 하나씩 놓여져 있고, 두 동전의 위치는 다르다.

버튼은 "왼쪽", "오른쪽", "위", "아래"와 같이 4가지가 있다. 버튼을 누르면 두 동전이 버튼에 쓰여 있는 방향으로 동시에 이동하게 된다.

- 동전이 이동하려는 칸이 벽이면, 동전은 이동하지 않는다.
- 동전이 이동하려는 방향에 칸이 없으면 동전은 보드 바깥으로 떨어진다.
- 그 외의 경우에는 이동하려는 방향으로 한 칸 이동한다.이동하려는 칸에 동전이 있는 경우에도 한 칸 이동한다.

두 동전 중 하나만 보드에서 떨어뜨리기 위해 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 보드의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 20)

둘째 줄부터 N개의 줄에는 보드의 상태가 주어진다.

- `o`: 동전
- `.`: 빈 칸
- `#`: 벽

동전의 개수는 항상 2개이다.

#### 출력

첫째 줄에 두 동전 중 하나만 보드에서 떨어뜨리기 위해 눌러야 하는 버튼의 최소 횟수를 출력한다. 만약, 두 동전을 떨어뜨릴 수 없거나, 버튼을 10번보다 많이 눌러야 한다면, -1을 출력한다.

<br/>

## 풀이

- 시간을 줄이기 위해 4차원 visited 배열을 두어, 두 동전이 동일한 위치에 있던 적이 있는 경우를 체크

  그리고 두 동전이 자리를 바꿔도 이후에는 같은 결과가 나올 것이므로

  `visited[y1][x1][y2][x2]` 와 `visited[y2][x2][y1][x1]` 모두 true로 체크

<br/>

```c++
#include <iostream>
#include <string>
#include <vector>
#include <queue>
using namespace std;
using pii = pair<int, int>;

int dy[4] = { 0, 0, -1, 1 };
int dx[4] = { -1, 1, 0, 0 };
int N, M, answer = 11;
bool visited[22][22][22][22];
string board[22];

struct Point {
	int y, x;
	Point(int _y, int _x) : y(_y), x(_x) {};
};

Point move(int sy, int sx, int d) {
	int ny = sy + dy[d], nx = sx + dx[d];
	if (ny < 0 || ny >= N || nx < 0 || nx >= M) return Point(-1, -1);
	return board[ny][nx] == '#' ? Point(sy, sx) : Point(ny, nx);
}

void f(Point p1, Point p2) {
	queue<pair<int, pair<Point, Point>>> q;
	visited[p1.y][p1.x][p2.y][p2.x] = true;
	visited[p2.y][p2.x][p1.y][p1.x] = true;
	q.push({ 0, {p1, p2} });

	while (!q.empty()) {
		int cnt = q.front().first;
		Point cur1 = q.front().second.first;
		Point cur2 = q.front().second.second;
		q.pop();

		if (cnt >= answer) continue;

		for (int i = 0; i < 4; i++) {
			Point n1 = move(cur1.y, cur1.x, i);
			Point n2 = move(cur2.y, cur2.x, i);

			if (n1.y == -1 && n1.x == -1 && n2.y == -1 && n2.x == -1) {
				continue;
			} else if ((n1.y == -1 && n1.x == -1) || (n2.y == -1 && n2.x == -1)) {
				answer = cnt + 1;
			} else {
				if (visited[n1.y][n1.x][n2.y][n2.x] || visited[n2.y][n2.x][n1.y][n1.x]) continue;

				visited[n1.y][n1.x][n2.y][n2.x] = true;
				visited[n2.y][n2.x][n1.y][n1.x] = true;
				q.push({ cnt + 1, {n1, n2} });
			}
		}
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cin >> N >> M;

	vector<Point> v;
	for (int i = 0; i < N; i++) {
		cin >> board[i];
		for (int j = 0; j < M; j++) {
			if (board[i][j] == 'o') {
				v.push_back(Point(i, j));
			}
		}
	}

	f(v[0], v[1]);
	cout << (answer == 11 ? -1 : answer);

	return 0;
}
```
