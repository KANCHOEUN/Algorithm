# 16724. 피리 부는 사나이

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 1 초      | 256 MB      | 4796 | 2150 | 1635      | 41.912%   |

## 문제

피리 부는 사나이 성우는 오늘도 피리를 분다.

성우가 피리를 불 때면 영과일 회원들은 자기도 모르게 성우가 정해놓은 방향대로 움직이기 시작한다. 성우가 정해놓은 방향은 총 4가지로 U, D, L, R이고 각각 위, 아래, 왼쪽, 오른쪽으로 이동하게 한다.

이를 지켜보던 재훈이는 더 이상 움직이기 힘들어하는 영과일 회원들을 지키기 위해 특정 지점에 ‘SAFE ZONE’ 이라는 최첨단 방음 시설을 만들어 회원들이 성우의 피리 소리를 듣지 못하게 하려고 한다. 하지만 예산이 넉넉하지 않은 재훈이는 성우가 설정해 놓은 방향을 분석해서 최소 개수의 ‘SAFE ZONE’을 만들려 한다.

성우가 설정한 방향 지도가 주어졌을 때 재훈이를 도와서 영과일 회원들이 지도 어느 구역에 있더라도 성우가 피리를 불 때 ‘SAFE ZONE’에 들어갈 수 있게 하는 ‘SAFE ZONE’의 최소 개수를 출력하는 프로그램을 작성하시오.

#### 입력

첫 번째 줄에 지도의 행의 수를 나타내는 N(1 ≤ N ≤ 1,000)과 지도의 열의 수를 나타내는 M(1 ≤ M ≤ 1,000)이 주어진다.

두 번째 줄부터 N개의 줄에 지도의 정보를 나타내는 길이가 M인 문자열이 주어진다.

지도 밖으로 나가는 방향의 입력은 주어지지 않는다.

#### 출력

첫 번째 줄에 ‘SAFE ZONE’의 최소 개수를 출력한다.

<br/>

## 풀이

맨 처음 예제만 보고, N x M 지도를 순차적으로 탐색하면서 visited 여부로 SAFE ZONE을 나누려 했다.

하지만 아래와 같은 경우에는 예외가 발생한다.

```
RRLLL
RRURL
```

처음 생각한 방식으로 하게 된다면, RRL / L / L 로 3개의 구간이 나누어지게 된다.

하지만 실제로는 RRLLL은 하나의 safe zone이 있어, 하나의 그룹으로 나누어야 한다.

이는 시작점을 어디로 하냐에 따라 서로 다른 사이클이 생기는데, 동일한 SAFE ZONE을 사용할 수 있기 때문에,

사이클 간 겹치는 점이 있을 수 있기 때문에 나타나는 현상이다.

따라서 이들을 하나의 그룹으로 묶어주기 위해, 총 세 개의 변수를 사용하였다.

<br/>

하나는 safe zone의 개수, 즉 그룹의 개수를 세는 **cnt 변수**이고,

다른 하나는 각 탐색을 나누기 위한 **t 변수**이다.

(여기서 탐색은 하나의 기준점을 시작으로 U/D/L/R을 이동하면서 사이클이 생기는 순간까지이다.)

마지막으로 각 탐색 별로 탐색이 끝날 때, 끝나는 이유가

- 다른 사이클과 겹쳐서 끝나는 건지
- 아니면 자신의 사이클이 만들어져서 끝나는 것인지

파악하기 위해 **flag 변수**를 두었다.

다른 사이클과 겹쳐서 끝나는 경우에는 flag 변수를 0으로 두었고,

자신의 사이클이 만들어진 경우, 즉 다른 사이클과 겹치는 구간이 있는 경우를 1로 두어,

safe zone의 개수, 즉 그룹의 개수를 하나 증가시켰다.

<br/>

```c++
#include <iostream>
#include <string>
using namespace std;

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

int board[1111][1111];
int check[1111][1111];
int N, M, cnt = 0, t = 1;

int f(int y, int x) {
	int flag = 1;
	while (1) {
		if (check[y][x]) {
			if (check[y][x] < t) flag = 0;
			break;
		}

		int tmp = y;
		check[y][x] = t;
		y += dy[board[y][x]];
		x += dx[board[tmp][x]];
	}
	return flag;
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	cin >> N >> M;
	string s;
	for (int i = 0; i < N; i++) {
		cin >> s;

		for (int j = 0; j < M; j++) {
			if (s[j] == 'U') board[i][j] = 0;
			else if (s[j] == 'D') board[i][j] = 1;
			else if (s[j] == 'L') board[i][j] = 2;
			else if (s[j] == 'R') board[i][j] = 3;
		}
	}

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			if (check[i][j]) continue;
			cnt += f(i, j);
			t++;
		}
	}

	cout << cnt;
	return 0;
}
```
