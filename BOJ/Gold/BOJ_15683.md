# 15683. 감시

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 초      | 512 MB      | 39171 | 18360 | 11010     | 43.713%   |

## 문제

스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.

| ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/1.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/2.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/3.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/4.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/5.png) |
| ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| 1번                                                                                   | 2번                                                                                   | 3번                                                                                   | 4번                                                                                   | 5번                                                                                   |

1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.

CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.

CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.

```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0
```

지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '`#`'로 나타내면 아래와 같다.

| `0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 # 6 0 0 0 0 0 0 0` | `0 0 0 0 0 0 0 0 0 0 0 0 # # 1 0 6 0 0 0 0 0 0 0` | `0 0 # 0 0 0 0 0 # 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0` | `0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 # 0 0 0` |
| ------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- |
| →                                                 | ←                                                 | ↑                                                 | ↓                                                 |

CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다.

```
0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5
```

위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.

| `0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5` | `0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5` | `0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5` | `0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5` |
| ------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔                                          | 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕                                          | 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔                                          | 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕                                          |

CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.

```
0 0 2 0 3
0 6 0 0 0
0 0 6 6 0
0 0 0 0 0
```

위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.

```
# # 2 # 3
0 6 # 0 #
0 0 6 6 #
0 0 0 0 #
```

사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)

둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다.

CCTV의 최대 개수는 8개를 넘지 않는다.

#### 출력

첫째 줄에 사각 지대의 최소 크기를 출력한다.

<br/>

## 풀이

1. cctv 좌표를 모아놓은 vector
2. 각 cctv의 방향을 설정하면서, 사각 지대의 최소 크기를 구해나가는 완전 탐색

DFS로 풀어나가는데, 각 cctv로 방향을 설정하기 전에

현재 상태를 미리 저장해놓는 tmp 배열을 두는데, 이는 지역 변수로 선언

<br/>

```c++
#include <iostream>
#include <vector>
#define INF 987654321
using namespace std;

int dy[4] = { -1, 0, 1, 0 }; // up, right, down, left
int dx[4] = { 0, 1, 0, -1 };

int N, M, res = INF;
int office[10][10];
vector<pair<int, int> > cctv;

// 시작 지점으로부터 벽을 만날 때까지 한 가지 방향으로 이동
void check(int y, int x, int d) {
	int ny = y, nx = x;

	d %= 4;
	while (1) {
		// 0은 빈 칸, 6은 벽
		ny += dy[d];
		nx += dx[d];

		if (ny < 0 || ny >= N || nx < 0 || nx >= M) break;
		if (office[ny][nx] == 6) break;

		if (office[ny][nx] == 0) {
			office[ny][nx] = -1;
		}
	}
}

// dfs: 모든 cctv들을 탐색
void dfs(int idx) {
	if (idx == cctv.size()) { // 최소 크기 구하기
		int cnt = 0;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				if (office[i][j] == 0) cnt++;
			}
		}
		if (cnt < res) res = cnt;
		return;
	}

	int tmp[10][10];
	int cy = cctv[idx].first;
	int cx = cctv[idx].second;

	// cctv 설치 전
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			tmp[i][j] = office[i][j];
		}
	}

	// cctv 방향 설정
	for (int d = 0; d < 4; d++) {
		int type = office[cy][cx];

		if (type == 1) {
			check(cy, cx, d);
		} else if (type == 2) {
			check(cy, cx, d);
			check(cy, cx, d + 2);
		} else if (type == 3) {
			check(cy, cx, d);
			check(cy, cx, d + 1);
		} else if (type == 4) {
			check(cy, cx, d);
			check(cy, cx, d + 1);
			check(cy, cx, d + 3);
		} else if (type == 5) {
			check(cy, cx, d);
			check(cy, cx, d + 1);
			check(cy, cx, d + 2);
			check(cy, cx, d + 3);
		}

		dfs(idx + 1);

		// cctv 설치 후, 원래대로 되돌리기
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				office[i][j] = tmp[i][j];
			}
		}
	}
}

int main() {
	cin >> N >> M;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cin >> office[i][j];
			if (0 < office[i][j] && office[i][j] < 6) {

				cctv.push_back({ i, j });
			}
		}
	}

	dfs(0);
	cout << res;

	return 0;
}
```
